# URL 단축기 설계

https://api-credit.kkuda.kr/api/v1/company?findType=3&value=소정&page=1 과 같이 긴 URL이 입력으로 주어졌을 때 서비스는 https://api-credit.kkuda.kr/api/v1/y7ke-ocwj와 같은 단축 URL을 결과로 제공해야 하는 상황입니다.

현재 책에서 산정한 기능적 요구사항은 아래와 같습니다.

1. URL 단축 : 주어진 긴 URL을 훨씬 짧게(7자리) 줄인다.
2. URL 리디렉션 : 축약된 URL로 HTTP 요청이 오면 원래 URL로 안내한다.

또한 성능적 요구사항은 아래와 같습니다.

1. 매일 1억 개의 단축 URL을 생성해야 한다.
2. URL 단축 서비스는 10년간 운영하기 때문에 최소 3650억개의 레코드를 생성하고 보관해야 한다.
3. 축약 전 URL의 평균 길이는 100이다.

---

### API 엔드포인트

URL 단축기는 기본적으로 두 개의 엔드포인트가 필요합니다. long url을 short url로 변환하는 url 단축용 엔드포인트와 단축 url로 http 요청이 들어왔을 때 원래의 long url을 보내주는 용도의 엔드포인트가 필요합니다.

<img width="500" height="400" alt="스크린샷 2025-07-18 오후 10 41 31" src="https://github.com/user-attachments/assets/dea20763-866c-4fc8-b1ef-79a8a5cabcb2" />


위 그림은 URL 단축기에 필요한 두 엔드포인트 중 단축 url을 원래의 long url로 바꿔주는 리디렉션 엔드포인트를 설명합니다. 브라우저에 단축 url을 보냈을 때 이를 받은 서버는 윈래의 Long url로 바꾸어서 301 상태 코드와 함께 원래의 long url을 내려줍니다. 이후 클라이언트에서 원래의 long url을 가지고 서버에 요청을 보냅니다.

리디렉션 엔드포인트를 구현하는 방식은 두 가지로 나뉩니다. 하나는 long url과 short url을 매핑하여 해당 매핑 정보를 저장하고 영구적으로 사용하는 방식이고, 다른 하나는 ‘일시적’으로 long url과 short url을 매핑하는 것입니다. 일시적 매핑이기 때문에 클라이언트의 요청은 언제나 단축 url 서버에 해당 url과 매핑된 long url을 얻어 해당 long url로 요청을 보내야합니다.

두 방법 모두 장단점을 가집니다.

long url과 short url을 영구적으로 매핑할 경우 처음 short url을 사용할 경우에만 해당 short url과 매핑되는 long url을 확인하기 위해 url 서버의 리디렉션 엔드포인트로 요청을 보냅니다. 이후 브라우저에서는 이 응답을 캐시하여 추후 같은 short url을 사용할 때는 캐시된 long url을 사용하면 됩니다. 따라서 url 서버의 부하를 줄일 수 있습니다. 

하지만 클릭 발생률이나 발생 위치를 추적하는 트래픽 분석 측면에서는 일시적으로 long url과 short url을 매핑하는 방식이 유리합니다. 

영구적 매핑의 경우 301 Permanently Moved 응답 코드를 사용하고 일시적 매핑의 경우는 302 Found 응답 코드를 사용하는것이 일반적입니다.

---

### URL 단축

그렇다면 이제는 long url을 short url로 단축해봅시다. url 단축에는 해시 함수를 사용합니다.

long url을 해시 값으로 대응시켜 해당 long url에 고유한 short url을 생성해야 합니다. 이때 우리는 long url을해시 값으로 대응시킬 해시 함수를 찾아야 합니다.

<img width="350" height="350" alt="스크린샷 2025-07-18 오후 10 41 45" src="https://github.com/user-attachments/assets/232d85aa-8a8c-4ae5-a372-629dcbf02a45" />


위 그림과 같이 url 단축에 사용될 해시 함수은 아래와 같은 요구사항을 만족해야 합니다.

1. 입력으로 주어지는 긴 url이 다른 값이면 해시 값도 달라야 한다.
2. 계산된 해시 값은 원래 입력으로 주어졌던 긴 url로 복원될 수 있어야 한다.

2번째 요구사항을 마치 우리가 만들 해시 함수가 short url을 다시 long url로 변환하는 리디렉션에 사용될것 같이 이야기하지만 결국에는 관계형데이터베이스를 사용합니다. 이 부분은 뒤에서 살펴보겠습니다.

---

### 상세 설계

지금까지는 url 단축기를 만드는 과정을 개괄적으로 살펴보았다면 이제는 상세히 설계해봅시다.

먼저 url서버의 리디렉션 엔드포인트를 위해서는 long url과 short url을 매핑해야 합니다. 이때 해시 테이블을 사용할 수 있지만, 메모리를 사용해야 하기 때문에 관계형 데이터베이스의 테이블로 long url과 그에 해당되는 short url을 저장합니다.

다음으로는 long url을 short url로 단축할 때 사용할 해시 함수를 구현해야 합니다.

책에서는 hashValue를 단축된 url 값으로 지칭하기 때문에 동일하게 지칭하겠습니다. short url은 [0-9, a-z, A-Z]의 문자들로 구성되기 때문에 총 62개의 문자의 조합입니다. 가장 앞에서 우리는 최소 3650억 개의 레코드를 생성하는 url 단축기를 만들어야 하기 때문에 short url의 길이 n을 결정하는 조건은 아래와 같습니다.

62의 n제곱 ≥ 3650억을 만족하는 n의 최솟값은 7입니다. 변환될 short url의 길이를 7로 정하고 long url을 단축하는 해시 함수를 살펴봅시다.

해시 함수를 구현하는 방법은 ‘해시 후 충돌 해소’ 방법과 ‘base-62 변환’법으로 크게 두 가지입니다.

먼저 ‘해시 후 충돌 해소’ 방법을 살펴봅시다.

이 방법은 이미 잘 알려진 CRC32, MD5, SHA-1와 같은 해시 함수를 사용하는 방법입니다. CRC32 해시 함수를 사용하면 long url을 8자리의 short url로 줄일 수 있습니다. 8자리도 충분히 줄인 url이라 생각되지만, 책에서는 7자리를 만족하기 위해 CRC32 해시 함수로 줄인 8자리의 값에 마지막 값을 잘라 냅니다. 처음 7개 글자만 사용하는 것입니다.

하지만 이 방식은 해시 결과가 충돌할 확률이 생깁니다. (높아집니다) 그래서 해시 함수의 결과가 충돌했을 때 즉 중복된 해시 결과가 생성되었을 때 long url 뒤에 사전에 정한 문자열을 추가하고 다시 해시 함수에 넣어 중복된 해시 결과를 해소합니다. 아래 그림과 같습니다.

<img width="600" height="300" alt="스크린샷 2025-07-18 오후 10 42 04" src="https://github.com/user-attachments/assets/ac1c2106-bed8-4fe8-b6d5-bf97e148ac22" />

하지만 ‘해시 후 충돌 해소’ 방법은 위 그림과 같이 short url이 생성되면 항상 이미 생성된 url인지 데이터베이스에 질의를 해야 하기 때문에 오버헤드가 존재합니다. 책에서는 이를 블룸 필터가 대안이 될 수 있다고 소개합니다.

두 번째는 ‘base-62 변환’ 방법입니다.

진법 변환은 url 단축기를 구현할 때 흔히 사용되는 방법입니다. 62진법을 선택한 이유는 생성될 short url이 62개의 문자의 조합으로 만들어질 수 있기 때문입니다.

10진수인 1157을 64진법으로 표현하면 2TX로 표현됩니다. 이렇게 진법 변환을 통해 1157를 2TX로 줄이는 방법이 ‘base-62 변환’ 방법입니다.

‘해시 후 충돌 해소’ 방법과 ‘base-62 변환’ 방법 사이의 차이를 표로 나타냈습니다.

<img width="600" height="400" alt="스크린샷 2025-07-18 오후 10 42 19" src="https://github.com/user-attachments/assets/2f4624cc-6309-4ea0-9a9f-24720881967f" />

---

### URL 단축기 상세 설계

책에서는 301 응답 코드를 내려주는 영구적 매핑 방식과 62진법 변환 기법을 사용하여 리디렉션 엔드포인트와 url 단축 엔드포인트를 설계했습니다.

<img width="450" height="450" alt="스크린샷 2025-07-18 오후 10 42 34" src="https://github.com/user-attachments/assets/eb87ab05-d56d-4ba5-a68d-e7e53f94a923" />

책에서 설계한 URL 단축기는 입력으로 long url을 받고 데이터베이스에 이미 매핑된 short url이 없는지 확인합니다. 
short url이 있다면 이전에 url 단축을 진행했던 long url이므로 해당 short url을 반환합니다.
만약 해당 long url이 데이터베이스에 없다면 새로운 유일한 ID를 생성하고 62진법 변환을 적용해 ID를 단축 url로 만듭니다. 
이때 주의할 점은 long url 자체를 진법 변환에 사용하는것이 아니라 유일 조건으로 생성된 ID를 62진법으로 변환해 단축 url을 만듭니다.
만들어진 ID와 short url은 long url과 함께 데이터베이스 스키마로 저장되고 테이블의 PK는 ID로 넣고 나머지 칼럼으로 short url과 long url을 저장합니다.

<img width="600" height="400" alt="스크린샷 2025-07-18 오후 10 49 35" src="https://github.com/user-attachments/assets/26d49ee3-74ed-4ebe-a74b-c41b2bcfa192" />

이때 유일한 ID를 생성하는 과정이 중요한 지점입니다. 특히 이 ID는 전역적으로 유일성이 보장되어야 하기 때문에 분산된 환경이라면 유일한 ID 생성에 유의해야 합니다.

그리고 URL 리디렉션 메커니즘을 시스템 설계 관점에서는 아래 그림과 같이 설계했습니다. 

<img width="600" height="400" alt="스크린샷 2025-07-18 오후 10 42 47" src="https://github.com/user-attachments/assets/2f1a2420-88ba-40e2-9518-07c2705a8504" />

쓰기보다 읽기를 더 자주하는 시스템이기 때문에 <long url, short url>의 쌍을 캐시에 저장해 성능을 높였습니다.

사용자가 short url을 클릭하면, 로드밸런서가 해당 요청을 웹 서버에 전달합니다.

단축 url이 이미 캐시되어 있다면 캐시에 매핑된 long url을 클라이언트에 전달하고, 캐시에 없다면 데이터베이스에 접근합니다.
