메시지 큐의 장점
- 결합도 완화
	- 컴포넌트 사이의 강한 결합이 사라져 각각 독립적으로 갱신 가능
- 규모 확장성 개선
	- 생산자와 소비자 시스템 규모를 트래필 부하에 맞게 독립적으로 늘릴 수 있음
- 가용성 개선
	- 시스템의 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 계속 상호작용 가능
- 성능 개선
	- 비동기 통신을 쉽게 할 수 있음
	- 생산자는 응답을 기다리지 않고 메시지를 보내며, 소비자는 읽을 메시지가 있을 때만 메시지 소비

![](./images/Pasted_image_20250709011706.png)

## 1단계 : 문제 이해 및 설계 범위 확정
메시지 큐의 기본 기능은 생산자는 메시지를 큐에 보내고, 소비자는 큐에서 메시지를 꺼내는 것이다.

### 전통적 메시지 큐와 다른점
`RabbitMQ`와 같은 전통적인 메시지 큐는 이벤트 스트리밍 플랫폼처럼 메시지 보관 문제를 중요하게 다루지 않는다. 전통적인 큐는 메시지가 소비자에 전달되기 충분한 기간 동안만 메모리에 보관한다.
처리 용량을 넘어간 경우 디스크에 보관하지만 아주 낮은 수준이다.

## 2단계 : 개략적 설계안 제시 및 동의 구하기
![](./images/Pasted_image_20250709013650.png)
- 생산자는 메시지를 메시지 큐에 발행
- 소비자는 큐를 구독하고 구독한 메시지를 소비
- 메시지 큐는 생산자와 소비자 사이의 결합을 느슨하게 함 -> 생산자와 소비장의 독립적인 운영 및 규모 확장 가능하게 하는 역할
- 생산자, 소비자는 모두 클라이언트/서버 모델 관점에서 클라이언트이고, 메시지 큐는 서버역할을 한다

가장 널리 쓰이는 모델은 `point-to-point`, `pub/sub`이다.

### 일대일 모델(point-to-point)
큐에 전송된 메시지는 오직 한 소비자만이 가져갈 수 있다.

![](./images/Pasted_image_20250709013800.png)

어떤 소비자가 메시지를 가져갔다는 사실을 큐에 알리면 해당 메시지는 큐에서 삭제된다.

### 발행-구독 모델(pub/sub)
토픽은 메시지를 주제별로 정리하는 데 사용되며 각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 가진다.
메시지를 보내고 받을 때 토픽에 보내고 받게 된다.
![](./images/Pasted_image_20250709014206.png)

이 모델에서 토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달된다.

### 토픽, 파티션, 브로커
토픽에 보관되는 데이터의 양이 커져 서버 한 대로 감당하기 힘든 경우 `파티션(샤딩)기법`을 활용한다
![](./images/Pasted_image_20250709014357.png)

토픽을 여러 파티션으로 분할하고 메시지를 모든 파티션에 균등하게 나눠 보낸다. 파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치하며, 파티션을 유지하는 서버를 `브로커`라고 부른다

각 토픽 파티션은 FIFO 큐처럼 동작한다. 이로인해 같은 파티션 안에서는 메시지 순서가 유지된다.
파티션 내에서의 메시지 위치를 `오프셋`이라고 한다.

생산자가 보낸 메시지는 해당 토픽의 파티션 중 하나로 보내지며 메시지에 사용자 ID같은 키가 붙은 경우 같은 키를 가진 파티션으로, 키가 없는 경우 무작위로 전송된다.

토픽을 구독한 소비자는 하나 이상의 파티션에서 데이터를 가져오며, 구독하는 소비자가 여럿인 경우 각 구독자는 파티션의 일부를 담당한다. 이 소비자들을 해당 토픽의 `소비자 그룹`이라 한다.

![](./images/Pasted_image_20250709014934.png)


### 소비자 그룹
하나의 소비자 그룹은 여러 토픽을 구독할 수 있고 오프셋을 별도로 관리한다. 예를 들어, 과금용 그룹, 회계용 그룹 등으로 나눌 수 있으며, 같은 그룹 내의 소비자는 메시지를 병렬로 소비할 수 있다.
![](./images/Pasted_image_20250709015054.png)

데이터를 병렬로 읽게되면 대역폭 측면에서는 좋지만 같은 파티션 안에 있는 메시지를 순서대로 소비할 수 없다.
이를 해결하기 위해 어떤 파티션의 메시지는 한 그룹 안에서 오직 한 소비자만 읽을 수 있도록 제약을 거는 방법으로 해결할 수 있다. 그러나 이런 경우 그룹 내 소비자 수가 구독하는 토픽의 파티션 수보다 크면 특정 소비자는 데이터를 읽을 수 없게 된다.

이 제약사항을 두면 결국 일대일 모델에 수렴하게 된다. 미리 충분한 파티션을 할당해 두면 파티션의 수를 동적으로 늘리는 일을 피할 수 있고, 처리 용량을 늘리기 위해 그냥 소비자를 더 추가하면 된다.

### 개략적 설계안
![](./images/Pasted_image_20250709172250.png)

- 클라이언트
	- 생산자 : 메시지를 특정 토픽으로 보낸다
	- 소비자 그룹 : 토픽을 구독하고 메시지를 소비한다
- 핵심 서비스 및 저장소
	- 브로커 : 파티션 유지. 하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지
	- 저장소
		- 데이터 저장소 : 메시지를 파티션 내 데이터 저장소에 보관
		- 상태 저장소 : 소비자 상태를 유지
		- 메타데이터 저장소 : 토픽 설정, 토픽 속성 등을 유지
	- 조정 서비스
		- 서비스 탐색 : 어떤 브로커가 살아있는지 알려줌
		- 리더 선출
			- 브로커 가운데 하나는 컨트롤러 역할 담당
			- 한 클러스터에는 반드시 활성 상태 컨트롤러가 하나 있어야함
			- 이 컨트롤러가 파티션의 배치를 책임진다.
		- 아파치 주키퍼 혹은 etcd가 컨트롤러 선출을 담당하는 컴포넌트로 사용


## 3단계 : 상세 설계
데이터 장기 보관과 높은 대역폭 제공을 위한 세가지 사항이 있다.
- 회전 디스크의 높은 순차 탐색 성능과 현대적 운영체제가 제공하는 적극적 디스크 캐시 전략을 이용하는 디스크 기반 자료 구조 활용
- 생산자로부터 소비자에게 전달될 때까지 메시지가 수정 없이 전송되도록 자료구조를 설계
- 일괄처리를 우선하는 시스템 설계

### 데이터 저장소
메시지 큐의 트래필 패턴은 아래와 같다.
- 읽기와 쓰기가 빈번하게 일어난다.
- 갱신/삭제 연산은 발생하지 않는다. 전통적인 메시지 큐는 메시지를 지속적으로 보관하지 않는다.
- 순차적인 읽기/쓰기가 대부분이다.

#### 선택 1 : 데이터 베이스
- 관계형 데이터베이스 : 토픽별로 테이블을 만든다. 토픽에 보내는 메시지는 해당 테이블에 새로운 레코드로 추가한다.
- NoSQL 데이터베이스 : 토픽별로 컬렉션을 만든다. 토픽에 보내는 메시지는 하나의 문서가 된다.

읽기/쓰기 연산이 동시에 대규모로 빈번하게 발생하는 경우 데이터베이스를 설계하기 어려우며 오히려 시스템 병목이 될 수 있다.

#### 선택 2 : 쓰기 우선 로그(WAL)
WAL은 새로운 항목이 추가되기만 하는 일반 파일을 말한다. MySQL의 복구 로그, 아파치 주키퍼가 해당 기술을 활용한다.
지속성을 보장해야하는 메시지는 WAL로 보관하는 것이 좋다. 
읽기/쓰기가 전부 순차적으로 진행되어 디스크가 좋은 성능을 보이며, 회전식 디스크 기반 저장장치는 큰 용량을 저렴한 가격에 제공한다는 장점이 있다.

![](./images/Pasted_image_20250709202346.png)

위 그림을 보면 새로운 메시지는 파티션 꼬리 부분에 추가되고, 오프셋이 점진적으로 증가한다.
파일의 크기가 무한정 커지는 것을 막기 위해 세그먼트 단위로 나누게 된다. 
세그먼트를 사용하면 새 메시지는 활성 상태의 세그먼트 파일에만 추가되며, 일정 한계에 도달하면 새 활성 세그먼트 파일이 만들어져 새로운 메시지를 수용하고 종전까지 활성상태였던 세그먼트 파일이 비활성 상태로 바뀐다.
비활성 상태인 세그먼트 파일은 읽기 요청만 처리하게 되며, 오래된 비활성 세그먼트 파일은 삭제될 수 있다.

![](./images/Pasted_image_20250709202824.png)

회전식 디스크가 느리다는 것은 편견이며, 순차적 데이터 접근 패턴을 활용하는 자료구조를 사용하면 빠르게 사용할 수 있다.
또한 현대적 운영체제는 적극적으로 캐시를 한다. WAL도 OS가 제공하는 디스크 캐시 기능을 활용한다.

### 메시지 자료 구조
메시지 자료 구조는 생산자, 메시지 큐, 소비자 사이의 계약을 포함한다.

`메시지 키`는 파티션을 정할 때 사용된다. 키가 주어지지 않은 메시지의 파티션은 무작위로 결정되고, 키가 주어진 경우 파티션은 `hash(key) % numPartitions`로 정해진다.
키는 문자열일 수도 있고 숫자일 수도 있으며 비즈니스 관련 정보가 담기는 것이 보통이다.
또한 메시지 큐 내부적으로 사용되기 때문에 클라이언트에게 노출되어서는 안된다.

`메시지 값`은 메시지의 내용인 페이로드(payload)를 말한다. 이는 일반 텍스트일 수도 있고 압축된 이진 블록일 수도 있다.

> **💡유의사항**
> 메시지의 키와 값은 키-값 저장소에서 이야기하는 키, 값과 다르다.
> 키-값 저장소에서 키는 고유하여 원하는 값을 키로 찾을 수 있지만,
> 메시지의 키는 고유할 필요가 없으며, 반드시 키가 필요한 것도 아니고 키를 사용하여 값을 찾을 필요도 없다.

이외에도 아래와 같은 필드들이 존재한다.
- 토픽 : 메시지가 속한 토픽 이름
- 파티션 : 메시지가 속한 파티션 ID
- 오프셋 : 파티션 내 메시지의 위치
- 타임스템프 : 메시지 저장된 시각
- 크기 : 메시지 크기
- CRC : 순환 중복 검사. 주어진 데이터의 무결성 보장하는 데 이용

### 일괄처리
생산자, 소비자, 메시지큐는 메시지를 가급적 일괄 처리한다.
일괄 처리를 하는 이유는 아래와 같다.
- 여러 메시지를 한 번의 네트워크 요청으로 전송하여 **값비싼 네트워크 왕복 비용 제거**
- 브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산 발생, 운영체제가 관리하는 디스크 캐시에 더 큰 규모의 연속된 공간 점유하게 된다. 이로인해 **더 높은 디스크 접근 대역폭을 달성**할 수 있다.

높은 대역폭과 낮은 응답 지연은 동시에 달성하기 어렵다.
시스템이 낮은 응답 지연이 중요한 전통적 메시지 큐로 이용되면 일괄처리 메시지 양을 낮춘다. 그러면 디스크 성능이 낮아지게 된다.
처리량을 높이기 위해서는 토픽당 파티션의 수를 늘린다. 이렇게 하면 낮아진 순차 쓰기 연산 대역폭을 벌충할 수 있다.

#### 생산자 측 작업 흐름
생산자가 어떠한 파티션에 메시지를 보내기 위해 `라우팅 계층`을 도입하는 방법이 있다.
이 라우팅 계층은 적절한 브로커에게 메시지를 보내는 역할을 한다.
브로커를 여러개로 복제하여 운용하는 경우 `리더 브로커`가 메시지를 받기에 가장 적절하다.

생산자가 파티션-1로 메시지를 보낼 때는 아래처럼 동작한다.
![](./images/Pasted_image_20250709233918.png)

1. 생산자가 메시지를 라우팅 계층으로 보낸다.
2. 라우팅 계층은 메타데이터 저장소에서 사본 분산 계획을 읽어 자기 캐시에 보관한다. 메시지가 도착하면 라우팅 계층은 파티션-1의 리더 사본에 보낸다.
3. 리더 사본이 우선 메시지를 받고 해당 리더를 따르는 다른 사본은 해당 리더로부터 데이터를 받는다.
4. 충분한 수의 사본이 동기화되면 리더는 데이터를 디스크에 기록한다. 데이터가 소비 가능 상태가 되는 것이 이 시점이다. 기록이 끝나면 생산자에게 회신을 보낸다.


리더와 사본이 필요한 이유는 `장애 감내`가 가능한 시스템을 만들기 위함이다.

위에서 설명한 동작은 여러 단점이 있다.
- 라우팅 계층 도입 시 거쳐야 할 네트워크 노드가 하나 더 늘어 오버헤드 발생
- 일괄 처리가 가능하면 효율을 높일 수 있지만 고려하지 않음

이러한 단점을 해결하기 위해 아래와 같이 수정을 한다.
![](./images/Pasted_image_20250709233928.png)

4.12에서는 라우팅 계층을 생산자 내부로 편입시키고 버퍼를 도입한다.
이렇게 변경하여 아래와 같은 장점이 생긴다.
- 네트워크를 거칠 필요가 줄어 전송 지연 감소
- 생산자가 메시지를 어느 파티션에 보낼지 결정하는 자신만의 로직을 가질 수 있음
- 전송할 메시지를 버퍼 메모리에 보관했다가 목적지로 일괄 전송하여 대역폭을 높일 수 있음

어느 정도 메시지를 일괄처리하는 것이 좋을지는 대역폭과 응답 지연 사이의 타협점을 찾는 것이다.
일괄처리 양을 늘리면 대역폭은 늘어나지만 응답 속도는 느려진다.
일괄처리 양을 줄이면 지연은 줄어들지만 대역폭은 손해를 본다.


소비자는 특정 파티션의 오프셋을 주고 해당 위치에서부터 이벤트를 묶어 가져온다.

### 푸시 vs 풀
#### 푸시 모델
- 장점
	- 낮은 지연 : 브로커가 메시지 받는 즉시 소비자에게 전달 가능
- 단점
	- 소비자 메시지 처리 속도가 생산자 메시지 생성 속도보다 느리면 소비자에게 큰 부하 걸릴 수 있음
	- 생산자가 데이터 전송 속도를 좌우하기 때문에 소비자는 그에 맞는 컴퓨팅 자원을 준비해 두어야 함

#### 풀 모델
- 장점
	- 소비자가 메시지 소비 속도를 결정
	- 메시지 소비 속도가 생산 속도보다 느린 경우 소비자를 늘려 해결, 혹은 생산 속도를 따라잡을 때까지 기다리는 것이 가능
	- 일괄 처리에 적합함. 소비자가 지난번 마지막으로 가져간 로그 위치 다음에 오는 모든 메시지를 한 번에 가져갈 수 있기 때문에 데이터의 공격적 일괄 처리에 더 적합함
- 단점
	- 브로커에 메시지가 없어도 소비자가 계속 데이털르 끌어가려고 하여 소비자 측 컴퓨팅 자원이 낭비됨. 이를 해결하기 위해 롱 풀링 모드를 지원함

![](./images/Pasted_image_20250710003009.png)

1. 소비자가 그룹 이름을 해싱하여 접속할 브로커 노드를 찾는다. 같은 그룹의 모든 소비자는 같은 브로커에 접근하게 되는데 이 브로커를 소비자 그룹의 `코디네이터`라고 부른다. 이 `코디네이터`는 소비자 그룹의 조정 작업을 담당한다.
2. 코디네이터가 해당 소비자를 그룹에 참여시키고 파티션-2를 할당한다. 파티션 배치 정책에는 라운드-로빈이나 범위 기반 정책 등 여러 가지가 있다.
3. 마지막으로 소비한 오프셋 이후 메시지를 가져온다. 오프셋 정보는 상태 저장소에 있다.
4. 메시지 처리 및 새로운 오프셋을 브로커에 보낸다.

### 소비자 재조정
`소비자 재조정`이란 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스이다.
이 프로세스는 새로운 소비자 합류, 기존 소비자가 그룹을 떠나는 경우, 어떤 소비자에게 장애가 발생하거나 파티션이 조정되는 경우 시작될 수 있다.

`코디네이터`는 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드이다. 이는 소비자로부터 오는 박동 메시지를 살피고 각 소비자의 파티션 내 오프셋 정보를 관리한다.

![](./images/Pasted_image_20250710004201.png)

- 코디네이터는 연결한 소비자 목록을 유지하며 목록에 변화가 생기면 해당 그룹의 새 리더를 선출한다.
- 새 리더는 새 파티션 배치 계획을 만들고 코디네이터에게 전달하고, 코디네이터가 모든 소비자에게 알린다.

코디네이터가 박동 신호가 사라지는 현상을 통해 소비자의 장애를 알아차리며, 이를 감지하면 재조정 프로세스를 시작하여 파티션을 재배치 한다.

![](./images/Pasted_image_20250710004633.png)

아래는 새로운 소비자 B가 그룹에 합류한 경우의 처리 흐름도이다. 
![](./images/Pasted_image_20250710004910.png)

아래는 기존 소비자 A가 그룹을 떠나는 경우의 처리 흐름도이다.
![](./images/Pasted_image_20250710004930.png)

아래는 소비자 A가 비정상적으로 가동을 중단한 경우에 대한 처리 흐름도이다.
![](./images/Pasted_image_20250710005333.png)


### 상태 저장소
상태 저장소에는 다음과 같은 정보가 저장된다.
- 소비자에 대한 파티션의 배치 관계
- 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋

소비자 상태 정보 데이터가 이용되는 패턴은 다음과 같다.
- 읽기와 쓰기가 빈번하게 발생하지만 양이 많지 않은 경우
- 데이터 갱신은 빈번하게 일어나지만 삭제되는 일이 거의 없는 경우
- 읽기와 쓰기 연산이 무작위적 패턴을 보이는 경우
- 데이터의 일관성이 중요한 경우
이 상태 데이터를 보관하기에는 주키퍼 같은 키-값 저장소를 이용하는 것이 바람직하다.
카프카는 오프셋 저장소로 주키퍼를 사용하다 카프카 브로커로 이전하였다.

### 메타데이터 저장소
메타데이터 저장소에는 토픽 설정이나 속성 정보를 보관한다. 파티션 수, 메시지 보관 기간, 사본 배치 정보 등이 있다.
이는 자주 변경되지 않고 양도 적지만 높은 일관성을 요구한다.
이러한 데이터 보관에 주키퍼가 적절하다.

### 주키퍼
주키퍼는 계층적 키-값 저장소 기능을 제공하는 서비스이다.
보통 분산 설정 서비스, 동기화 서비스, 그리고 이름 레지스트리 등으로 이용된다.

![](./images/Pasted_image_20250710210256.png)

### 복제
하드웨어 장애를 해결하기 위해 복제를 사용한다.
생산자는 파티션에 메시지를 보낼 때 리더에게만 보내며, 다른 사본은 리더에서 새 메시지를 지속적으로 가져와 동기화한다.
메시지를 완전히 동기화한 사본의 개수가 지정된 임계값을 넘는 경우 리더가 생산자에게 메시지를 잘 받았다는 응답을 보낸다.

![](./images/Pasted_image_20250710211639.png)

`사본 분산 계획`은 조정 서비스의 도움으로 브로커 노드 가운데 하나가 리더로 선출되면 해당 리더 브로커 노드가 만들고 메타데이터 저장소에 보관한다.

### 사본 동기화
동기화가 의미하는 바는 토픽의 설정에 따라 달라진다.
예를들어 replica.lag.max.messages의 값이 4로 설정된 경우 단순 사본에 보관된 메시지 개수와 리더 사이의 차이가 3인 경우 해당 사본은 여전히 `ISR(동기화된 사본)`이다.
또한 리더는 항상 ISR 상태이다.

![](./images/Pasted_image_20250710212644.png)

- 리더 사본의 오프셋 값은 13이다. 두 개의 새로운 메시지가 기록되었지만 사본 간의 합의가 이루어지지 않았다. 합의 오프셋이 의미하는 바는 이전에 기록된 모든 메시지가 이미 ISR 집합 내 모든 사본에 동기화가 끝났다는 뜻이다.
- 사본-2, 3은 이미 리더 상태를 동기화하여 ISR이 되었기 때문에 새로운 메시지를 가져올 수 있다.
- 사본-4는 리더 상태를 충분히 따라잡지 못해 아직 ISR이 아니다.

ISR은 성능과 영속성 사이의 타협점이다.
메시지를 소실하지 않는 가장 안전한 방법은 메시지를 받았다는 응답을 보내기 전 모든 사본을 동기화하는 것이다. 그러나 이는 파티션 전부가 느려지거나 못쓰게 되는 문제가 생길 수 있다.

#### ACK=all
![](./images/Pasted_image_20250710213033.png)

ACK=all로 설정된 경우 생산자는 모든 ISR이 모든 메시지를 수신한 뒤에 ACK 응답을 받는다.
이는 ISR의 응답을 기다려야 하기 떄문에 메시지를 보내기 위한 시간이 길어진다.
영속성 측면에서 가장 좋은 구성이다.

#### ACK=1
![](./images/Pasted_image_20250710213351.png)

ACK=1인 경우 생산자는 리더가 메시지를 저장하고 나면 바로 ACK 응답을 받는다.
데이터가 동기화될 때까지 기다리지 않아 응답 지연이 개선되지만 ACK 보낸 후 리더에 장애가 생길 시 복구할 수 없다.
데이터가 사라져도 되며, 낮은 응답 지연을 보장해야하는 시스템에 적합하다.

#### ACK=0
![](./images/Pasted_image_20250710213512.png)

ACK=0인 경우 보낸 메시지에 대한 수신 확인 메시지를 기다리지 않고 계속 메시지를 전송하며 재시도를 하지 않는다.
지표 수집이나 데이터 로깅 등 처리해야 하는 메시지 양이 많고 때로 데이터 손실이 발생해도 상관 없는 경우 사용한다.


리더 사본에 요청이 몰려도 ISR 요건을 만족하는 사본에 메시지를 가져가지 않는 이유는 아래와 같다.
- 설계 및 운영이 단순
- 특정 파티션의 메시지는 같은 소비자 그룹 안에서 오직 한 소비자만 읽어갈 수 있기 때문에 리더 사본에 대한 연결이 많지 않음
- 아주 인기 있는 토픽이 아닌 경우 리더 사본에 대한 연결의 수가 많지 않음
- 아주 인기 있는 토픽의 경우 파티션 및 소비자 수를 늘려 규모를 확장할 수 있음

소비자의 위치가 리더 사본이 존재하는 데이터 센터와 다른 지역인 경우는 지역적으로 가까운 ISR 사본에서 메시지를 읽는 선택지를 고려할 수도 있다.

보통 각 파티션 담당 리더가 자기 사본들이 어느 메시지까지 가져갔는지 추적하여 ISR 목록을 관리한다.

### 규모 확장성
#### 생산자
생산자는 새로운 생산자를 추가하거나 삭제함으로써 규모 확장성을 달성할 수 있다.

#### 소비자
소비자 그룹은 독립적이기 때문에 새 소비자 그룹은 쉽게 추가 및 삭제를 할 수 있다.
추가/삭제 혹은 장애로 제거되는 경우 재조정 메커니즘이 처리한다.

#### 브로커
![](./images/Pasted_image_20250710214124.png)

위 그림은 브로커 노드에 장애가 발생한 경우 처리 과정을 보여준다.

브로커의 결함 내성을 높이기 위해 아래와 같은 사항을 고려해야한다.
- 메시지가 성공적으로 합의되었다고 판단하려면 얼마나 많은 사본에 메시지가 반영되어야 하는가? 응답 지연과 안전성 사이의 균형을 찾아야 한다.
- 같은 노드에 데이터를 복제하면 해당 노드 장애 발생 시 해당 파티션이 완전히 소실될 수 있다. 따라서 같은 노드에 사본을 두면 안된다.
- 사본 수와 사본 위치를 정할 때 데이터 안전성, 자원 유지에 드는 비용, 응답 지연 등을 고려해야 한다. 사본을 여러 데이터 센터에 분산하는 것이 안전하다. 이 때 데이터 미러링을 도입하여 데이터 센터 간 데이터 복사를 용이하게 하는 방법도 있다.

아래는 새 브로커 느드의 추가 과정이다.
![](./images/Pasted_image_20250711002050.png)

### 파티션
토픽 규모 늘리거나, 대역폭 조정, 가용성과 대역폭 사이의 균형을 맞출 때 파티션의 수를 조정한다.
이때 소비자는 재조정을 시행하기 때문에 생산자와 소비자의 안정성에는 영향을 미치지 않는다.

![](./images/Pasted_image_20250711005439.png)

- 지속적으로 보관된 메시지는 기존 파티션에 존재하며 해당 데이터가 이동하지 않는다
- 새로운 파티션이 추가되면 그 후 오는 메시지를 3개로 나눠서 보관한다.


![](./images/Pasted_image_20250711005527.png)

- 파티션 3이 삭제되면 이후 새로운 메시지를 1, 2에서만 받는다.
- 해당 파티션 데이터를 읽고 있는 사용자가 있을 수 있어 바로 제거하지 않고 일정 시간 유지한다.
- 완전히 삭제되기 전까지 세 파티션 모두 메시지를 읽는다. 실제로 제거된 경우 생산자 그룹은 재조정 작업을 진행한다.

### 메시지 전달 방식
#### 최대 한 번
![](./images/Pasted_image_20250711005901.png)
- 생산자가 토픽에 비동기적으로 메시지를 보내고 응답을 기다리지 않는다. ACK=0을 이용한다.
소량의 데이터 손실을 감수할 수 있는 애플리케이션에 적합하다.

#### 최소 한 번
![](./images/Pasted_image_20250711010050.png)
- 생산자가 동기/비동기적으로 보낼 수 있고 ACK=1, all을 이용한다. 메시지가 브로커에게 전달된 것을 반드시 확인한다.
- 소비자는 데이터를 성공적으로 처리한 뒤에만 오프셋을 갱신한다.

메시지가 소실되는 일은 없지만 같은 메시지가 여러번 전송될 수 있다.
데이터 중복에 문제가 없거나 소비자가 중복을 제거할 수 있는 애플리케이션이라면 괜찮은 방법이다.

#### 정확히 한 번
![](./images/Pasted_image_20250711010330.png)
시스템의 성능 및 구현 복잡도 측면에서 큰 대가를 치뤄야 한다.
금융 관련 응용에 이 방식이 적합하다.

### 고급 기능
#### 메시지 필터링
주문 시스템이 토픽에 주문과 관련된 모든 활동을 전송하지만 지불 시스템이 결재나 환불 관련 메시지에만 관심이 있는 경우 메시지 필터링이 필요하다.

브로커에서 구현할 필터링 로직은 메시지의 내용을 추출해서는 안된다.
필터링에 사용될 데이터를 메시지의 메타데이터 영역에 두어 브로커가 효율적으로 읽을 수 있도록 한다.

메시지마다 태그를 두는 방법이 있다.
메시지에 태그 목록을 필드로 두어 대부분의 필터링을 처리할 수 있다.
![](./images/Pasted_image_20250711010759.png)

#### 메시지 지연 전송 및 예약 전송
주문을 넣은 후 30분 안에 결재가 이루어지지 않으면 주문을 취소하고 싶을 때 사용할 수 있다.

이런 메시지는 토픽에 바로 저장하지 않고 브로커 내부의 임시 저장소에 넣어두고 시간이 되면 토픽으로 옮긴다.
![](./images/Pasted_image_20250711011011.png)

이 시스템의 핵심 컴포넌트는 임시 저장소 및 타이밍 기능이다.
- 하나 이상의 특별 메시지 토픽을 임시 저장소로 활용할 수 있다.
- 메시지 지연 전송 전용 메시지 큐를 사용
- 계층적 타이밍 휠을 사용

메시지 예약 전송도 지연 전송과 유사한 메커니즘을 가지고 있다.


![](./images/Pasted_image_20250711011318.png)
