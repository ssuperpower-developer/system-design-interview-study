# 문자 메시징 앱 설계

문자 메시지 서비스는 사용자가 API 게이트웨이를 통해 서비스를 요청한다.

문자 메시지 서비스는 아래 세 가지 서비스 구성된다.

- 발신자 서비스 : 발신자로부터 메시지를 받아 즉시 수신자에게 전달하고 메시지 서비스에 기록한다.
- 메시지 서비스 : 발신자는 이 서비스에 보낸 메시지를 요청할 수 있고, 수신자는 이 서비스에 받은 메시지와 받지 않은 메시지를 모두 요청할 수 있다.
- 연결 서비스 : 사용자의 활성과 차단된 연결을 저장하고 검색하며, 다른 사용자를 연락처 목록에 추가하고, 다른 사용자가 메시지를 보내는 것을 차단한다.

## 연결 서비스

사용자의 연결(활성 연결과 차단된 연결 모두 포함)은 사용자의 기기 또는 브라우저 쿠키나 로컬 스토리지에 저장돼야 한다. 따라서 연결 서비스는 사용자가 기기를 변경하는 경우에 대비한 이 데이터의 백업이 되거나 여러 기기 간에 이 데이터를 동기화하는 역할을 한다.

### 발신자 차단

발신자를 차단한 경우 혹은 수신자를 차단한 경우 모두 연결 서비스를 통해 차단된 연결임을 확인한다.

차단은 모든 계층(클라이언트, 서버)에서 구현해야 한다. 서버로의 트래픽을 줄이기 위해 차단된 수신자 연결은 사용자의 기기에 저장돼야 한다. 그러면 사용자가 이 수신자와 상호작용하는 것을 기기가 방지할 수 있고, 서버가 이런 원치 않은 상호작용을 차단할 수 있다.

하지만 사용자는 여러 기기에서 같은 차단 또는 차단 해제 요청을 보낼 수 있기 때문에 일관성 문제가 발생할 수 있다.

사용자가 한 기기에서 차단 요청을 하고 나서 차단 해제 요청을 하고 다른 기기에서도 차단 요청을 한 경우 최종 상태가 발신자를 차단할지 차단 해제할지 불분명하다. 기기의 타임스탬프로 요청의 순서를 결정하는 방법을 떠올릴 수 있는데 기기의 시계를 완벽하게 동기화할 수 없기 때문에 무의미하다.

이 일반적인 일관성 문제는 오프라인 기능이 쓰기 작업을 포함할 때 발생한다.

해결책은 두 가지이다.

1. 사용자에게 각 기기의 최종 상태를 확인하게 요청하는 것이다.
    1. 사용자가 한 기기에서 이런 쓰기 작업을 수행하면 해당 기기가 서버를 업데이트한다.
    2. 다른 기기가 서버와 동기화하고 자신의 상태가 서버와 다르다는 것을 발견한다.
    3. 기기는 사용자에게 최종 상태를 확인하게 요청하는 UI를 제공한다.
2. 쓰기 작업과 오프라인 기능에 제한을 두는 것이다.
    1. 기기가 발신자 차단 요청을 보내면 다른 모든 기기가 서버와 동기화될 때까지 차단 해제를 허용하지 않아야 한다.

## 발신자 서비스

발신자 서비스는 발신자로부터 메시지를 받아 거의 실시간으로 수신자에게 전달하는 단일 기능의 확장성, 가용성, 성능에 최적화되어 있다.

예측하지 못한 트래픽 급증이 있으면 이러한 메시지를 임시 저장소에 버퍼링해 충분한 리소스가 있을 때 처리하고 전달할 수 있어야 한다.

### 메시지 보내기

다음과 같이 진행된다. 대부분의 처리와 메시지 전달은 메시지 전송 서비스가 수행한다.

1. 클라이언트에서 사용자가 발신자ID, 수신자ID, 본문 문자열을 포함한 메시지를 작성한다. 
정송 확인과 읽음 확인은 false로 초기화된다. 클라이언트는 본문을 암호화한 다음 발신자 서비스에 메시지를 보낸다.
2. 발신자 서비스의 새 메시지 서비스는 메시지 요청을 받아 새 메시지 카프카 토픽에 생성한 다음, 발신자에게 200 성공을 반환한다.
이때 클라이언트 메시지 발송 요청이 제대로 형식화됐는지 등의 간단한 유효성 검사를 하고 유효하지 않으면 400 오류를 반환한다. 
3. 새 메시지 서비스에서 생성된 새 메시지 카프카 토픽을 메시지 전송 서비스의 메시지 생성기에서 소비하고 각 수신자에 별도의 메시지를 생성한다.
호스트는 메시지를 수신자 토픽이라고 부르는 카프카 토픽에 생성한다. 
(이때 호스트는 메시지 생성기인가? 아닌것 같다. 아래를 보면, 각 메시지 전송 서비스 호스트는 여러 수신자와 웹소켓 연결이 있다..고 한다) 
호스트가 생성한 수신자 토픽을 메시지 소비자 서비스가 소비한 후 다음 단계를 수행한다.
    1. 발신자가 차단됐어야 하는지 확인한다. 메시지 전송 서비스는 모든 메시지를 연결 서비스에 요청하는 대신 이 데이터를 저장해야 한다. 메시지에 차단된 발신자가 있다면 클라이언트 사이드 차단 메커니즘이 실패했음을 나타내며, 버그나 악의적인 활동 때문일 수 있다. 이때 개발자에게 경보를 트리거해야 한다
    2. 각 메시지 전송 서비스 호스트는 여러 수신자와 웹소켓 연결이 있다. 
    카프카 토픽을 사용하면 각 호스트가 메시지를 전달할 준비가 됐을 때만 카프카 토픽에서 소비할 수 있으므로 각 호스트가 더 많은 수의 수신자를 처리할 수 있다.
    서비스는 주키퍼 같은 분산 구성 서비스를 사용해 기기에 호스트를 할당할 수 있다. 이 주키퍼 서비스는 특정 수신자를 처리하는 호스트를 반환하는 적절한 API 엔드포인트를 제공하는 다른 서비스 뒤에 있을 수 있다. 이를 호스트 할당자 서비스라고 부를 수 있다.
4. 발신자 서비스가 수신자 클라이언트에 메시지를 보낸다. 대부분 수신자 기기가 꺼져 있거나 인터넷 연결이 없어 수신자 클라이언트에 메시지를 전달 할 수 없으면, 메시지가 이미 메시지 서비스에 기록됐고 나중에 기기가 검색할 수 있으므로 메시지를 그냥 버릴 수 있다.

[수신자 카프카 토픽에서 메시지를 소비한 다음 수신자에게 보내는 시퀀즈 다이어그램]

메시지 소비자 서비스에서 수신자 토픽으로 메시지 요청을 가져온다.

메시지를 생성한다. 이때 차단 상태를 확인한다.

메시지 소비자 서비스는 호스트 할당자 서비스로부터 할당된 호스트를 가져온다. 그리고 메시지 소비자 서비스에 메시징 정보를 저장한다. 이는 병렬적으로 진행된다.

마지막으로 메시지 소비자 서비스는 수신자에서 메시지를 보낸다.

### Q1. 어떻게 기기가 받지 않은 메시지만 검색할 수 있을까?

→ 한 가지 가능성은 메시지 서비스가 사용자의 어떤 기기가 해당 메시지를 받지 않았는지 기록하고 이를 사용해 각 기기가 받지 않은 메시지만 검색할 수 있는 엔드포인트를 제공하는 것이다.

### Q2. 메시지 순서를 해결하려면 어떤 접근 방식을 취해야 하는가?

일관된 해싱을 사용해 특정 수신자 메시지를 특정 카프카 파티션에 생성할 수 있다. 이렇게 하면 특정 수신자 메시지가 순서대로 소비되고 수신된다.

다른 방법은 레디스 같은 인메모리 데이터베이스를 사용해 수신자-파티션 매핑을 저장하고, 특정 파티션에 과부하가 걸리지 않게 이 매핑을 필요에 따라 조정하는 것이다.

## 메시지 서비스

메시지 서비스는 메시지 로그 역할을 한다. 사용자는 다음 목적으로 요청할 수 있다.

- 사용자가 새 기기에 로그인했거나 기기의 앱 저장소가 지워질 때 기기는 과거에 보낸 메시지와 받은 메시지 모두를 다운로드해야 한다.
- 메시지를 전달 받을 수 없는 환경이었다가, 다시 클라리언트가 전달 받을 수 있는 환경으로 돌아오면 그동안 보내진 메시지를 메시지 서비스에 요청할 수 있다.

시스템은 종단 간 암호화를 사용해야 하므로 시스템을 통과하는 메시지는 암호화된다.

### 메시지 전송 단계

1. 백엔드 호스트가 호스트 할당자 서비스에 요청을 하면 이 서비스는 주키퍼를 조회해 어떤 호스트가 수신자 개별 클라이언트나 채팅방을 처리할지 결정한다. 아직 할당된 호스트가 없다면 주키퍼가 호스트를 할당할 수 있다.
2. 백엔드 호스트가 수신자 호스트에 메시지를 보낸다.

### Q1. 메시지 순서를 해결하려면 어떤 접근 방식을 취해야 하는가?

각 메시지에는 발신자 클라이언트의 타임스탬프가 있다. 나중 메시지가 이전 메시지보다 먼저 성공적으로 처리되고 전달될 수 있다. 수신자 기기가 메시지를 순서대로 표시하고 사용자가 기기를 보고 있다면 이전 메시지가 갑자기 나중 메시지 앞에 나타나 사용자를 혼란스럽게 만들 수 있다. 해결책은 나중 메시지가 이미 수신자의 기기에 전달됐다면 이전 메시지를 버리는 것이다. 수신자 클라이언트가 메시지를 받으면 더 나중 타임스탬프를 가진 메시지가 있는지 확인하고, 있다면 적절한 오류 메시지와 함께 422 오류를 반환할 수 있다.
오류는 발신자의 기기로 전파될 수 있다. 메시지를 보낸 사용자는 성공적으로 전달된 나중 메시지 이후에 나타날 것이라는 것을 알고 메시지를 다시 보내기로 결정할 수 있다.

## 요약

---

간단한 문자 메시징 앱 시스템 설계에 대한 주요 논의는 많은 수의 클라이언트 간에 대량의 메시지를 어떻게 라우팅할 것인가에 관한 것이다.

채팅 시스템에서 트래픽 급증을 처리하는 확장 가능하고 비용 효율적인 기술은 메시지 큐를 사용하는 것이다. 그러나 트래픽 급증 시 지연 시간은 증가한다.

호스트에 할당되는 사용자 수를 줄여 지연 시간을 줄일 수 있지만, 비용이 더 높아진다는 트레이드오프가 있다

두 솔루션 모두 호스트 실패를 처리하고 호스트의 사용자를 다른 호스트에 재할당해야 한다.
